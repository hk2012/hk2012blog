---
title: JVM 8为什么要增加元空间
category: 文档
tag: 总结
date: 2024-02-13 18:00:00
abbrlink: 5
---
## JVM 8为什么要增加元空间 ?

### 持久代 ###

持久代中包含了虚拟机中所有可通过反射获取到的数据，比如Class和Method对象。不同的Java虚拟机之间可能会进行类共享，因此持久代又分为只读区和读写区。

JVM用于描述应用程序中用到的类和方法的元数据也存储在持久代中。JVM运行时会用到多少持久代的空间取决于应用程序用到了多少类。除此之外，Java SE库中的类和方法也都存储在这里。

如果JVM发现有的类已经不再需要了，它会去回收（卸载）这些类，将它们的空间释放出来给其它类使用。Full GC会进行持久代的回收。

JVM中类的元数据在Java堆中的存储区域。
Java类对应的HotSpot虚拟机中的内部表示也存储在这里。
类的层级信息，字段，名字。
方法的编译信息及字节码。
变量
常量池和符号解析
**持久代的大小**
它的上限是MaxPermSize，默认是64M
Java堆中的连续区域 : 如果存储在非连续的堆空间中的话，要定位出持久代到新对象的引用非常复杂并且耗时。卡表（card table），是一种记忆集（Remembered Set），它用来记录某个内存代中普通对象指针（oops）的修改。
持久代用完后，会抛出OutOfMemoryError "PermGen space"异常。解决方案：应用程序清理引用来触发类卸载；增加MaxPermSize的大小。
需要多大的持久代空间取决于类的数量，方法的大小，以及常量池的大小。
**为什么移除持久代 ？**

1、它的大小是在启动时固定好的——很难进行调优。-XX:MaxPermSize，设置成多少好呢？ 2、HotSpot的内部类型也是Java对象：它可能会在Full GC中被移动，同时它对应用不透明，且是非强类型的，难以跟踪调试，还需要存储元数据的元数据信息（meta-metadata）。
3、简化Full GC：每一个回收器有专门的元数据迭代器。
4、可以在GC不进行暂停的情况下并发地释放类数据。
5、使得原来受限于持久代的一些改进未来有可能实现

### 元空间 ###

持久代的空间被彻底地删除了，它被一个叫元空间的区域所替代了。持久代删除了之后，很明显，JVM会忽略PermSize和MaxPermSize这两个参数，还有就是你再也看不到java.lang.OutOfMemoryError: PermGen error的异常了。原来类的静态变量和Interned Strings 都被转移到了java堆区，

只有class元数据才在元空间。

JDK 8的HotSpot JVM现在使用的是本地内存来表示类的元数据，这个区域就叫做元空间。

**元空间的特点：**

- 充分利用了Java语言规范中的好处：类及相关的元数据的生命周期与类加载器的一致。

- 每个加载器有专门的存储空间

- 只进行线性分配

- 不会单独回收某个类

- 省掉了GC扫描及压缩的时间

- 元空间里的对象的位置是固定的

- 如果GC发现某个类加载器不再存活了，会把相关的空间整个回收掉

