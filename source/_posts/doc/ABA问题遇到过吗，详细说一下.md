---
title: ABA问题遇到过吗，详细说一下
category: 文档
tag: 总结
date: 2024-02-11 09:00:00
abbrlink: 28
---
## ABA问题遇到过吗，详细说一下

1. 有两个线程同时去修改一个变量的值，比如线程1、线程2，都更新变量值，将变量值从A更新成B。
2. 首先线程1获取到CPU的时间片，线程2由于某些原因发生阻塞进行等待，此时线程1进行比较更新（CompareAndSwap），成功将变量的值从A更新成B。
3. 更新完毕之后，恰好又有线程3进来想要把变量的值从B更新成A，线程3进行比较更新，成功将变量的值从B更新成A。
4. 线程2获取到CPU的时间片，然后进行比较更新，发现值是预期的A，然后有更新成了B。但是线程1并不知道，该值已经有了A->B->A这个过程，这也就是我们常说的ABA问题。

举个具体的例子：

小明在提款机，提取了50元，因为提款机问题，
有两个线程，同时把余额从100变为50

线程1（提款机）：获取当前值100，期望更新为50，

线程2（提款机）：获取当前值100，期望更新为50，

线程1成功执行，线程2某种原因block了，这时，某人给小明汇款50

线程3（默认）：获取当前值50，期望更新为100，

这时候线程3成功执行，余额变为100，

线程2从Block中恢复，获取到的也是100，compare之后，继续更新余额为50！！！

此时可以看到，实际余额应该为100（100-50+50），但是实际上变为了50（100-50+50-50）

#### 如何避免ABA问题：

可以通过加版本号或者加时间戳解决，或者保证单向递增或者递减就不会存在此类问题。

atomic包下的**AtomicStampedReference类**：其compareAndSet方法首先检查当前引用**是否等于预期引用**，并且当前标志**是否等于预期标志**，如果全部相等，则以原子方式将该引用的该标志的值设置为给定的更新值。



#### CAS导致的其他问题

1、只能保证一个共享变量的原子操作

当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij。从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。

2、循环时间长开销大

自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。

